import { 
  BadGatewayException,
  Injectable, 
  InternalServerErrorException, 
  UnauthorizedException 
} from '@nestjs/common'
import { 
  CreateUserDTO,
  CreateUserResponseDTO,
  LoginUserDTO,
  LoginResponseDTO
} from './dto'
import { Repository } from 'typeorm'
import { User } from './entities/user.entity'
import { InjectRepository } from '@nestjs/typeorm'
import { ErrorRequestProvider } from 'src/providers/error-request.provider'
import { LoginException } from 'src/providers/login-exception.provider'
import * as bcrypt from 'bcryptjs'
import { JwtPayload } from './interface/jwt-payload'
import { JwtService } from '@nestjs/jwt'
import { LogoutUserResponseDTO } from './dto/logout-user-response.dto'
import { LogoutUserDTO } from './dto/logout-user.dto'


@Injectable()
export class AuthService {

  private blacklistedTokens: string[] = []

  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,

    private readonly errorRequestProvider: ErrorRequestProvider,

    private readonly jwtService: JwtService

  ){}

  async findAll(): Promise<User[]> {
    return this.userRepository.find()
  }


  async create(createUserDTO: CreateUserDTO):Promise<CreateUserResponseDTO> {
  
    try{
      const { password, confirmPassword, ...userData } = createUserDTO

      if(password !== confirmPassword) throw new BadGatewayException('password no coincide')

      const user = this.userRepository.create({
        ...userData,
        password: bcrypt.hashSync( password,10 )
      })

      await this.userRepository.save(user)

      return {
        message: 'registrado'
      }

    }
    catch(error){
      this.errorRequestProvider.handleDBException(error)
      //throw new InternalServerErrorException('Error al registrar el usuario');
    }
    
  }

/**
 * This function performs user login authentication by checking the provided email and password against
 * the stored user credentials and generating a JWT token upon successful authentication.
 * @param {LoginUserDto} loginUserDto - The `loginUserDto` parameter in the `login` function is an
 * object that contains the user's email and password. It is used to authenticate and log in a user by
 * checking the provided email and password against the stored user data in the database.
 * @returns The `login` function is returning an object with three properties:
 * 1. A "message" property with a welcome message that includes the user's full name.
 * 2. A "user" property containing the user object retrieved from the database.
 * 3. A "token" property containing a JWT token generated using the user's email address.
 */
  async login( loginUserDTO:LoginUserDTO ): Promise<LoginResponseDTO> {

    const { username,password } = loginUserDTO

    const user = await this.userRepository.findOne({
      where: {username},
      select:{
        email: true,
        username:true,
        password: true,
        id: true,
        roles:true,
        isActive: true
      }
    })

    if( !user ){
      throw new LoginException('username','User Not Found')
    }

    if( !bcrypt.compareSync(password, user.password) ){
      throw new LoginException('password','Password doen\'t match')
    }

    const token = this.getJwtToken({
      id: user.id,
      email: user.email,
      username: user.username,
      is_active: user.isActive,
      roles: user.roles,
    })


    //return user

    return {
      message: 'Bienvenido',
      user,
      token,
    }

  }

  async logout(logoutUserDTO:LogoutUserDTO): Promise<LogoutUserResponseDTO> {

    const {token} = logoutUserDTO

    const decoded = this.jwtService.decode(token);

    if (!decoded) {
      throw new UnauthorizedException('Invalid token');
    }

    this.blacklistedTokens.push(token);
    return { message: 'Logged out successfully' };
  }
  
/**
 * The function `getJwtToken` generates a JWT token by signing the provided payload using the
 * `jwtService`.
 * @param {JwtPayload} payload - The `payload` parameter in the `getJwtToken` function is of type
 * `JwtPayload`, which likely contains the data that will be used to generate the JWT token. This data
 * could include information such as the user's ID, role, and any other relevant details needed for
 * authentication and authorization.
 * @returns The function `getJwtToken` is returning a JWT token that is generated by signing the
 * provided `payload` using the `jwtService`.
 */
  private getJwtToken( payload: JwtPayload ){

    return this.jwtService.sign(payload)

  }

  async checkAuthStatus(user:User){
    return{
      ...user,
      token:this.getJwtToken({
        id: user.id,
        email: user.email,
        username: user.username,
        is_active: user.isActive,
        roles:user.roles
      })
    }
  }

  isTokenBlacklisted(token: string): boolean {
    return this.blacklistedTokens.includes(token);
  }

}
